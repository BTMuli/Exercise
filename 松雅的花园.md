【问题描述】

​    冬天到了，松雅觉得是时候给她的花园浇水了。

​    她的花园由 *n* 个连续的苗圃组成，编号从 1*~n*。其中的 *k* 个苗圃安装有水龙头（第 *i* 个水龙头位于苗圃 *xi*），当水龙头打开的时候，可以同时给相邻的苗圃浇水。1个时间单位后，她可以给苗圃 *xi* 浇好水，2个时间单位后，她可以给 [*xi-*1*, xi+*1] 范围内的苗圃（如果有）浇好水，在 *j* 个时间单位后，她可以给[*xi-*(*j-*1)*，xi+*(*j-*1)]内的苗圃（如果有）浇好水。

![QQ图片20181116110952.png](http://202.197.98.89/userfiles/image/15423379928750431443514.png)

图中白色表示该苗圃没有水龙头，红色表示该苗圃有一个水龙头

![QQ图片20181116111326.png](http://202.197.98.89/userfiles/image/15423380349870326793514.png)

水龙头打开2个时间单位后，白色部分表示没有浇到水的苗圃，蓝色部分表示已浇水的苗圃

​    松雅希望在同一时刻打开所有水龙头，她想知道，最少到多少个时间单位以后整个花园都能浇好水。

【输入形式】

​    第一行一个整数表示测试数据的组数。

​    接下来T组测试数据 ，每组数据的第一行包含两个整数 *n* 和 *k*，分别表示她的花园中的苗圃数和水龙头数，接下来的一行为 *k* 个整数 *xi*，表示第 *i* 个水龙头所在的位置，输入保证对于每个 *i >=*2*，xi -* 1 *< xi* 。

​    本题只考虑整数单位时间。
【输出形式】

​    对于每个测试用例，每个用例输出一行一个整数，表示所有水龙头同时打开后整个花园浇好水所需要的最小时间单位数。
【样例输入】

```
3
5 1
3
3 3
1 2 3
4 1
1
```

【样例输出】

```
3
1
4
```

【解题思路】

+ 将只有一个水龙头拿出来单独分析
+ 将两端的拿出来单独分析
+ 比较中间相隔距离最大值

【源代码】（通过数据测试）

```c++
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int t; //测试组数
    cin >> t;
    int n[t], k[t], ans[t];

    for (int i = 0; i < t; i++)
    {
        int temp = 0; //中转数
        cin >> n[i];  //苗圃数
        cin >> k[i];  //水龙头数
        int p[k[i]];  //存储水龙头位置
        for (int j = 0; j < k[i]; j++)
            cin >> p[j];
        if (k[i] == 1)//只有一个水龙头
        {
            temp = max(p[0], n[i] - p[0] + 1);
            ans[i] = temp;
        }
        else
        {
            for (int j = 0; j < k[i] - 1; j++)
            {
                if (p[j + 1] - p[j] > temp)
                    temp = p[j + 1] - p[j];
            }
            ans[i] = max(temp / 2 + 1, n[i] - p[k[i] - 1] + 1);//比较右端
            ans[i] = max(ans[i], p[0]);//比较左端
        }
    }
    for (int i = 0; i < t; i++)
        cout << ans[i] << endl;
    return 0;
}
```

