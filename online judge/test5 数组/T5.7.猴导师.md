【问题描述】

​    猴子王国里有n只猴子，第i只猴子有ri种技能。

​    猴子a可以是猴子b的导师，当且仅当猴子a的技能严格大于猴子b的技能(ra>rb)，并且a和b无性格冲突，有性格冲突的猴子在一起会打架。

​    给定每个猴子的技能值，以及有性格冲突的k对猴子。对于每只猴子，找出可以成为其他猴子导师的个数。
【输入形式】

​    第一行包含两个正整数n和k，表示猴子的数量以及有性格冲突的猴子的对数。

​    第二行为一个整数序列，r1、r2、...、rn，其中ri表示第i只猴子的技能数。

​    接下来的k行，每行为两个正整数x、y(1≤ x、y≤n，x≠ y)，表示有性格冲突的一对猴子编号，输入保证(x,y)和(y,x)不会同时出现。

【输出形式】

​    输出n个整数，第i个整数表示第i个猴子能成为多少只猴子的导师。
【样例输入】

```
4 2
10 4 10 15
1 2
4 3
```

【样例输出】

```
0 0 1 2
```

【解题思路】

+ 构建数组存储技能
+ 构建数组存储冲突猴子编号
+ 对每个猴子进行分析，其与其他任意猴子，若技能数较大，判断是否冲突
+ 判断冲突方法：
  + 将这两个猴子的编号与冲突猴子编号进行比较
  + 若相同 temp2++
  + temp2 初始值为0

【源代码】（通过数据测试）

```c++
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n, k;
    cin >> n >> k;              //猴子数与冲突猴子对数
    int skill[n];               //技能数组
    for (int i = 0; i < n; i++) //技能数据输入
        cin >> skill[i];
    int x[k], y[k];
    for (int i = 0; i < k; i++) //冲突猴子编号输入
        cin >> x[i] >> y[i];
    int ans[n];
    for (int i = 0; i < n; i++) //对每个猴子遍历，研究对象为i
    {
        int temp1 = 0;               //中转数据
        for (int j = 0; j < n; j++) //对剩下的每个猴子遍历
        {
            if (skill[i] > skill[j]) //比较两个不同猴子的技能
            {
                int temp2 = 0;
                for (int h = 0; h < k; h++) //对冲突猴子计数
                {
                    if (((x[h] == (i + 1)) && (y[h] == (j + 1))) || (x[h] == (j + 1) && (y[h] == (i + 1))))
                        temp2++;
                }
                if(temp2!=0)
                    continue;
                else
                    temp1++;
            }
        }
        ans[i] = temp1;
    }
    for (int i = 0; i < n; i++)
        cout << ans[i] << " ";
    return 0;
}
```

