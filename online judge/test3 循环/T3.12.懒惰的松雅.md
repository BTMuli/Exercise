【问题描述】

   松雅喜欢睡懒觉，有一天，她必须在 *hh*:*mm* 的时间起来去跟她的合伙人讨论新开旅馆的事情。然而，她讨厌醒来，她希望在一个幸运时间设置一个闹钟以减少痛苦，这样她可以反复按“小睡一会儿”按钮，该按钮每次可延迟 *x* 分钟，直到 *hh*:*mm* 这个时间醒来，她想知道最少需要按多少次这个按钮。

   如果一个时间的数字中包含'7'，则她认为是幸运时间，例如：13:07和17:20是幸运的，而00:48和21:34不是。

   注意，设置闹钟的时间与醒来的时间不一定在同一天，输入保证对每个醒来时间都有一个幸运时间。

   正常地，可以找到一个最小的非负整数 *y* 使得在时间 *hh*:*mm* 之前的 *y\*x* 分钟是一个幸运时间，即包含数字'7'。

   时间采用24小时制，因此在23:59之后是00:00。
【输入形式】

   输入的第一行包含一个正整数 *x* (1 *≤ \*x* ≤* 60)。

   第二行包含两个整数，分别代表小时与分钟（ *hh*:*mm* ）。

【输出形式】

   输出一行一个整数，表示松雅需要按“小睡一会儿”按钮的最小次数。

【样例输入1】

```
3
11 23
```

【样例输出1】

```
2
```

【样例输入2】

```
5
1 7
```

【样例输出2】

```
0
```

【样例说明】

在第一个样例中，她需要在11:23分醒来，她可以设置闹钟的幸运时间为11:17，因此她需要在11:17分和11:20按两次按钮。

在第二个样例中，01:07就是幸运时间。



【解题思路】

+ 先判断当前时间是否为幸运时间，若不是，往前x分钟继续判断。
+ 注意跨天与时间进制。



【源代码】（通过样例测试）；

```c++
#include <iostream>
using namespace std;
bool judge(int hh, int mm);
int main() 
{
    int x, hh, mm;
    cin >> x >> hh >> mm;
    for (int i = 0;;i++)
    {
        if(judge(hh,mm)==true)
        {
            cout<<i;
            break;
        }
        else
        {
            if(mm>=x)
                mm -= x;
            else
            {
                mm = mm + 60 - x;
                if(hh==0)
                    hh = 23;
                else
                    hh--;
            }
        }
    }
    return 0;
}
bool judge(int hh, int mm)
{
   if(hh%10!=7&&mm%10!=7)
       return false;
   else
       return true;
}   
```

