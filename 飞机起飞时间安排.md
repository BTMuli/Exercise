【问题描述】

​    阿迪在一个大型机场担任飞机跑道交通管制员，他控制一个通常用于着陆的跑道。因此，他有一个未来一段时间飞机着陆的时间安排，每次着陆持续时间为1分钟。

​    他被要求在安排表中插入一次起飞，起飞本身需要1分钟，但出于安全考虑，起飞和着陆之间应有至少s分钟的时间间隔。 

​    请找出阿迪能插入的起飞的最早时间。

【输入形式】

​    输入的第一行包含两个整数n和s（1≤*n*≤1001≤n≤100, 1≤*s*≤601≤s≤60），分别表示在时间安排表中的着陆的航班数量以及在着陆与起飞之间的最小允许时间（以分钟计）。

​    接下来的n行，每行包含两个整数h和m （0≤*h*≤230≤h≤23, 0≤*m*≤590≤m≤59），表示飞机着陆的时间，以小时和分钟计，从当前时刻开始（也就是说当前时刻是0时0分），这些时间以递增的顺序给出。

【输出形式】

​    输出两个整数h和m，代表可以插入的起飞的最早时间的小时和分钟。
【样例输入】

```
6 60
0 0
1 20
3 21
5 0
19 30
23 40
```

【样例输出】

```
6 1
```

【解题思路】

1. 判断相邻时间段内时长是否符合题意
2. 考虑跨天的情况
3. 考虑相隔时间刚刚好的情况

【源代码】（通过测试）

```c++
#include <iostream>
using namespace std;
int time(int h1, int m1, int h2, int m2); //计算两次着陆之间的时间差，输出分钟
int main()
{
    int n; //着陆航班数量
    int s; //着陆与起飞最小允许时间
    cin >> n >> s;
    int H[n], M[n]; //飞机着陆时间
    for (int i = 0; i < n; i++)
        cin >> H[i] >> M[i];
    int h, m;
    h = m = 0;
    for (int i = 0; i < n; i++)
    {
        if (i == 0 && (time(H[n - 1], M[n - 1], H[i], M[i]) > (2 * s + 2))) //考虑前一天
        {
            m += (M[n - 1] + s + 1);
            if (m >= 60)
            {
                int temp = m / 60;
                m %= 60;
                h += temp;
            }
            h += H[n - 1];
            if (h >= 24)
            {
                h %= 24;
                break;
            }
            else
                h = m = 0; //考虑今天
        }
        else if (time(H[i], M[i], H[i + 1], M[i + 1]) >= (2 * s + 2) && i < n - 1) //相邻时间计算
        {
            m += (M[i] + s + 1);
            if (m >= 60)
            {
                int temp = m / 60;
                m %= 60;
                h += temp;
            }
            h += H[i];
            if (h >= 24)
                h %= 24;
            break;
        }
        if (i == n - 1)
        {
            m += (M[i] + s + 1);
            if (m >= 60)
            {
                int temp = m / 60;
                m %= 60;
                h += temp;
            }
            h += H[i];
            if (h >= 24)
                h %= 24;
        }
    }
    cout << h << " " << m;
    return 0;
}
int time(int h1, int m1, int h2, int m2) //考虑跨天
{
    int m = 0;
    if (m2 - m1 < 0)
    {
        m += (m2 + 60 - m1);
        h2--;
    }
    else
        m += (m2 - m1);
    if (h2 - h1 < 0)
        m = m + (h2 + 24 - h1) * 60;
    else
        m = m + (h2 - h1) * 60;
    return m;
}
```

